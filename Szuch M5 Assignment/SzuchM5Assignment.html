<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>CMPS 260: Module 5 Programming Assignment</title>
    <style>
      * {
        font-family: monospace;
      }
    </style>
    <script>
      // NOTE: You must implement the data structures using the no prototype approach.
      //       This is what the book uses, so you can copy it.
      //       See also: https://it.pointpark.edu/tutorials/no-prototype-vs-prototype/

      // NOTE: Please review the following links regularly:
      //       https://it.pointpark.edu/tutorials/arrays-vs-objects/
      //       https://it.pointpark.edu/tutorials/no-prototype-vs-prototype/
      //       https://it.pointpark.edu/tutorials/implementation-vs-interface/

      //------------------------------------//
      // The binary and binary search trees //
      //------------------------------------//
      console.log("The binary and binary search trees");

      function BinarySearchTree() {
        function Node(key) {
          this.key = key;
          this.left = null;
          this.right = null;
        }

        // the root node
        var root = null;

        // helper functions
        function insertNode(node, newNode) {
          if (newNode.key < node.key) {
            // go to left
            if (node.left === null) {
              // no left node yet so assign
              node.left = newNode;
            } else {
              // move down tree and repeat
              insertNode(node.left, newNode);
            }
          } else {
            // go to right
            if (node.right === null) {
              // no right node yet so assign
              node.right = newNode;
            } else {
              // move down tree and repeat
              insertNode(node.right, newNode);
            }
          }
        }

        this.insert = function (key) {
          // insert new key in the tree
          var newNode = new Node(key);
          if (root === null) {
            // no nodes yet
            root = newNode;
          } else {
            // find insert location through insertNode
            insertNode(root, newNode);
          }
        };

        this.search = function (key) {
          // search for key and return true if found, false otherwise
          return searchNode(root, key);
        };

        var searchNode = function (node, key) {
          if (node === null) {
            return false;
          }
          if (key < node.key) {
            return searchNode(node.left, key);
          } else if (key > node.key) {
            return searchNode(node.right, key);
          } else {
            return true;
          }
        };

        // DONE
        this.min = function () {
          // return the minimum key in the tree
          return minNode(root);
        };

        // DONE
        var minNode = function (node) {
          if (node) {
            while (node && node.left !== null) {
              node = node.left;
            }
            return node.key;
          }
          return null;
        };

        this.max = function () {
          // return the maximum key in the tree
          return maxNode(root);
        };

        var maxNode = function (node) {
          if (node) {
            while (node && node.right !== null) {
              node = node.right;
            }
            return node.key;
          }
          return null;
        };

        // DONE
        this.remove = function (key) {
          // removes the key from the tree
          root = removeNode(root, key);
        };

        // DONE
        var removeNode = function (node, key) {
          if (node === null) {
            return null;
          }
          if (key < node.key) {
            node.left = removeNode(node.left, key);
            return node;
          } else if (key > node.key) {
            node.right = removeNode(node.right, key);
            return node;
          } else {
            if (node.left === null && node.right === null) {
              node = null;
              return node;
            }
            if (node.left === null) {
              node = node.right;
              return node;
            } else if (node.right === null) {
              node = node.left;
              return node;
            }
            var aux = findMinNode(node.right);
            node.key = aux.key;
            node.right = removeNode(node.right, aux.key);
            return node;
          }
        };

        // DONE
        this.print = function () {
          function print(node) {
            // check if not is not null
            if (node !== null) {
              // text for left child
              var leftChild = node.left !== null ? node.left.key : "None";
              // text for right child
              var rightChild = node.right !== null ? node.right.key : "None";
              // print output
              console.log(
                leftChild + " <-- " + node.key + " --> " + rightChild
              );
              // traverse left
              print(node.left);
              // traverse right
              print(node.right);
            }
          }
          console.log("===tree===");
          print(root);
          console.log("==========");
        };

        // In order traversal

        // DONE
        this.inOrderTraverse = function (callback) {
          inOrderTraverseNode(root, callback);
        };

        // DONE
        var inOrderTraverseNode = function (node, callback) {
          if (node !== null) {
            inOrderTraverseNode(node.left, callback);
            callback(node.key);
            inOrderTraverseNode(node.right, callback);
          }
        };

        // Pre-order traversal

        // DONE
        this.preOrderTraverse = function (callback) {
          preOrderTraverseNode(root, callback);
        };

        // DONE
        var preOrderTraverseNode = function (node, callback) {
          if (node !== null) {
            callback(node.key);
            preOrderTraverseNode(node.left, callback);
            preOrderTraverseNode(node.right, callback);
          }
        };

        // Post-order traversal
        this.postOrderTraverse = function (callback) {
          postOrderTraverseNode(root, callback);
        };

        var postOrderTraverseNode = function (node, callback) {
          if (node !== null) {
            postOrderTraverseNode(node.left, callback);
            postOrderTraverseNode(node.right, callback);
            callback(node.key);
          }
        };
      }

      // 1. Complete the construction of the tree below based on the example from
      //    the book.

      var tree = new BinarySearchTree();
      tree.insert(11);
      tree.insert(7);
      tree.insert(15);
      tree.insert(5);
      tree.insert(3);
      tree.insert(9);
      tree.insert(8);
      tree.insert(10);
      tree.insert(13);
      tree.insert(12);
      tree.insert(14);
      tree.insert(20);
      tree.insert(18);
      tree.insert(25);
      tree.insert(6);
      // copy rest from book
      tree.print();

      //----------------//
      // Tree traversal //
      //----------------//
      console.log("/-----------------------------/");
      console.log("Tree traversal");

      function printNode(value) {
        console.log(value);
      }

      // 1. Implement in-order traversal. Test your implementation with the
      //    printNode() function given above.
      //    NOTE: in-order means all keys are visited in sorted order.

      console.log("In-order traversal");

      function printNode(value) {
        console.log(value);
      }
      tree.inOrderTraverse(printNode);

      // 2. Implement pre-order traversal. Test your implementation with the
      //    printNode() function given above.
      //    NOTE: pre-order means a node is visited prior to its descendants.

      console.log("Pre-order traversal");

      function printNode(value) {
        console.log(value);
      }
      tree.preOrderTraverse(printNode);

      // 3. Implement post-order traversal. Test your implementation with the
      //    printNode() function given above.
      //    NOTE: pre-order means a node is visited after its descendants.

      console.log("Post-order traversal");

      function printNode(value) {
        console.log(value);
      }
      tree.postOrderTraverse(printNode);

      console.log("/-----------------------------/");

      //--------------------------------//
      // Searching for values in a tree //
      //--------------------------------//
      console.log("Searching for values in a tree");

      // 1. Implement the min method above and show that it works.

      console.log("Min: " + tree.min());

      // 2. Implement the max method above and show that it works.
      console.log("Max: " + tree.max());

      // 3. Implement the search method above and show that it works.
      console.log(tree.search(1) ? "Key 1 found." : "Key 1 not found.");
      console.log(tree.search(8) ? "Key 8 found." : "Key 8 not found.");

      //--------------------------//
      // Creating the Graph class //
      //--------------------------//
      console.log("/-----------------------------/");
      console.log("Creating the Graph class");

      // 1. Implement the Graph class.
      function Graph() {
        var vertices = [];
        var adjList = new Map();

        // Add vertex
        this.addVertex = function (v) {
          vertices.push(v);
          adjList.set(v, []);
        };

        // Add edge
        this.addEdge = function (v, w) {
          adjList.get(v).push(w);
          adjList.get(w).push(v);
        };

        // toString
        this.toString = function () {
          var s = "";
          for (var i = 0; i < vertices.length; i++) {
            s += vertices[i] + " -> ";
            var neighbors = adjList.get(vertices[i]);
            for (var j = 0; j < neighbors.length; j++) {
              s += neighbors[j] + " ";
            }
            s += "\n";
          }
          return s;
        };

        // Breadth-first search
        var initializeColor = function () {
          var color = [];
          for (var i = 0; i < vertices.length; i++) {
            color[vertices[i]] = "white";
          }
          return color;
        };

        this.bfs = function (v, callback) {
          var color = initializeColor(),
            queue = new Queue();
          queue.enqueue(v);

          while (!queue.isEmpty()) {
            var u = queue.dequeue(),
              neighbors = adjList.get(u);
            color[u] = "grey";
            for (var i = 0; i < neighbors.length; i++) {
              var w = neighbors[i];
              if (color[w] === "white") {
                color[w] = "grey";
                queue.enqueue(w);
              }
            }
            color[u] = "black";
            if (callback) {
              callback(u);
            }
          }
        };

        // Depth-first search
        this.dfs = function (callback) {
          var color = initializeColor();

          for (var i = 0; i < vertices.length; i++) {
            if (color[vertices[i]] === "white") {
              dfsVisit(vertices[i], color, callback);
            }
          }
        };

        var dfsVisit = function (u, color, callback) {
          color[u] = "grey";
          if (callback) {
            callback(u);
          }
          var neighbors = adjList.get(u);
          for (var i = 0; i < neighbors.length; i++) {
            var w = neighbors[i];
            if (color[w] === "white") {
              dfsVisit(w, color, callback);
            }
          }
          color[u] = "black";
        };
      }

      // 2. Test the Graph class with the example from the book.

      var graph = new Graph();
      var myVertices = ["A", "B", "C", "D", "E", "F", "G", "H", "I"];
      for (var i = 0; i < myVertices.length; i++) {
        graph.addVertex(myVertices[i]);
      }

      function Queue() {
        this.enqueue = function (element) {
          items.push(element);
        };

        this.dequeue = function () {
          return items.shift();
        };

        this.front = function () {
          return items[0];
        };

        this.isEmpty = function () {
          return items.length == 0;
        };

        this.size = function () {
          return items.length;
        };

        this.print = function () {
          console.log(items.toString());
        };
      }

      var items = [];

      graph.addEdge("A", "B");
      graph.addEdge("A", "C");
      graph.addEdge("A", "D");
      graph.addEdge("C", "D");
      graph.addEdge("C", "G");
      graph.addEdge("D", "G");
      graph.addEdge("D", "H");
      graph.addEdge("B", "E");
      graph.addEdge("B", "F");
      graph.addEdge("E", "I");

      console.log(graph.toString());

      console.log("/-----------------------------/");
      //------------------//
      // Graph traversals //
      //------------------//
      console.log("Graph traversals");

      // 1. Implement breadth-first search in the Graph class above.
      console.log("Breadth-first search:");

      function printNode(value) {
        console.log("Visited vertex: " + value);
      }
      graph.bfs(myVertices[0], printNode);

      // 2. Implement depth-first search in the Graph class above.
      console.log("Depth-first search:");
      graph.dfs(printNode);

      //--------------------------//
      // Shortest path algorithms //
      //--------------------------//
      console.log("/-----------------------------/");
      console.log("Shortest path algorithms");

      // 1. Implement Dijkstra's algorithm.
      //    NOTE: Replace INF (used in the book) with Infinity.

      // 2. Test your implementation of Dijkstra's algorithm.
      console.log("Dijkstra's algorithm:");

      var Graph = function () {
        this.graph = [
          [0, 2, 4, 0, 0, 0],
          [0, 0, 2, 4, 2, 0],
          [0, 0, 0, 0, 3, 0],
          [0, 0, 0, 0, 0, 2],
          [0, 0, 0, 3, 0, 2],
          [0, 0, 0, 0, 0, 0],
        ];

        this.dijkstra = function (src) {
          var dist = [],
            visited = [],
            length = this.graph.length;

          for (var i = 0; i < length; i++) {
            dist[i] = Infinity;
            visited[i] = false;
          }
          dist[src] = 0;

          for (var i = 0; i < length - 1; i++) {
            var u = minDistance(dist, visited);
            visited[u] = true;

            for (var v = 0; v < length; v++) {
              if (
                !visited[v] &&
                this.graph[u][v] != 0 &&
                dist[u] != Infinity &&
                dist[u] + this.graph[u][v] < dist[v]
              ) {
                dist[v] = dist[u] + this.graph[u][v];
              }
            }
          }
          return dist;
        };

        var minDistance = function (dist, visited) {
          var min = Infinity,
            minIndex = -1;

          for (var v = 0; v < dist.length; v++) {
            if (visited[v] == false && dist[v] <= min) {
              min = dist[v];
              minIndex = v;
            }
          }
          return minIndex;
        };
      };

      var myGraph = new Graph();
      console.log(myGraph.dijkstra(0));
    </script>
  </head>
  <body>
    See console!
  </body>
</html>
